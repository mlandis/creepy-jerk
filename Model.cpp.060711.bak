/*
 * Model.cpp
 *
 *  Created on: Mar 7, 2011
 *      Author: mlandis
 */

#include "Model.h"


#define REAL(z,i) ((z)[2*(i)])
#define IMAG(z,i) ((z)[2*(i)+1])
//#define PI 3.1415926535897932384626433832795

#define RESEAT 1
#define LAMBDA_ONLY 0
#define SIGMA_ONLY 0
#define TAU1_ONLY 0
#define TAU2_ONLY 0

Model::Model(Expression* ep, MbRandom* rp, Settings* sp, Topology* tp)
{

	expressionPtr = ep;
	randomPtr = rp;
	settingsPtr = sp;
	topologyPtr = tp;

	numTaxa = expressionPtr->getNumTaxa();
	numNodes = 2 * numTaxa - 1;
	numBranches = numNodes - 1;
	numTranscripts = expressionPtr->getNumTranscripts();
	numTimepoints = expressionPtr->getNumTimepoints();

	tableId = 0;

	initializeParms();
	initializeFFT();
	initializeCondLikes();

}

Model::~Model() {
	// TODO Auto-generated destructor stub

	for (std::list<Table*>::iterator it_t = tableList.begin(); it_t != tableList.end(); it_t++)
	{
		delete (*it_t);
	}
	for (std::list<Patron*>::iterator it_p = patronList.begin(); it_p != patronList.end(); it_p++)
	{
		delete (*it_p);
	}
	delete [] theta;
	delete [] likeVals;
	//delete [] like;
	delete [] tip1;
	delete [] tip2;
	// delete condLikes;

	delete alpha;
}



void Model::initializeCondLikes(void)
{
	// [space][node][locus][timepoint][step]
	condLikes = new CondLikes(expressionPtr, settingsPtr);



	// Assigns tip likelihoods equal to the observed expression levels under the characteristic function.
	for (std::list<Patron*>::iterator it_p = patronList.begin(); it_p != patronList.end(); it_p++)
	{
		// transcript index
		int j = (*it_p)->getId();

		//double* cl_real = condLikes->getCls(1,i,j,k,0);
		for (int i = 0; i < numTaxa; i++)
		{
			for (int k = 0; k < numTimepoints; k++)
			{
				for (int l = 0; l < numSteps; l++)
				{
					//(*(cl_real + 2*l)) = GSL_REAL((*it_p)->getCfData(i,k,l));
					//(*(cl_real + 2*l + 1)) = GSL_IMAG((*it_p)->getCfData(i,k,l));

					double re_cf = GSL_REAL((*it_p)->getCfData(i,k,l));
					double im_cf = GSL_IMAG((*it_p)->getCfData(i,k,l));

					double* re_cl = condLikes->getCls(0,i,j,k,2*l);
					double* im_cl = condLikes->getCls(0,i,j,k,2*l+1);
					(*re_cl) = re_cf;
					(*im_cl) = im_cf;

					//double* cl_real2 = condLikes->getCls(1,i,j,k,2*l);
					//(*cl_real2) = GSL_REAL((*it_p)->getCfData(i,k,l));
					//double* cl_imag = condLikes->getCls(1,i,j,k,2*l+1);
					//(*cl_imag) = GSL_IMAG((*it_p)->getCfData(i,k,l));

				}
			}
		}
		std::cout << (*it_p)->getName() << " added.\n";
	}




/*
	for (std::list<Patron*>::iterator it_p = patronList.begin(); it_p != patronList.end(); it_p++)
	{
		for (int i = 0; i < numTaxa; i++)
		{
			for (int j = 0; j < numTranscripts; j++)
			{
				for (int k = 0; k < numTimepoints; k++)
				{
					//double* cl_real = condLikes->getCls(1,i,j,k,0);
					for (int l = 0; l < numSteps; l++)
					{
						//(*(cl_real + 2*l)) = GSL_REAL((*it_p)->getCfData(i,k,l));
						//(*(cl_real + 2*l + 1)) = GSL_IMAG((*it_p)->getCfData(i,k,l));
						double re_cf = GSL_REAL((*it_p)->getCfData(i,k,l))

						double* cl_real2 = condLikes->getCls(1,i,j,k,2*l);
						(*cl_real2) = GSL_REAL((*it_p)->getCfData(i,k,l));
						double* cl_imag = condLikes->getCls(1,i,j,k,2*l+1);
						(*cl_imag) = GSL_IMAG((*it_p)->getCfData(i,k,l));

					}
				}
			}
		}
		//std::cout << (*it_p)->getName() << " added.\n";
	}
*/

/*
	int trans = 0;
	for (std::list<Patron*>::iterator it_p = patronList.begin(); it_p != patronList.end(); it_p++)
	{

		Patron* p = *it_p;
		double* clL = condLikes->getCls(0,0,trans,0,0);
				condLikes->
		for (int i = 0; i < numSteps; i++)
		{
			gsl_complex complex_tip_L1 = p->getCfData(0,0,i);
			gsl_complex complex_tip_R1 = p->getCfData(1,0,i);
			gsl_complex complex_tip_L2 = gsl_complex_rect(clL->at(i), clL->at(i+1));
			gsl_complex complex_tip_R2 = gsl_complex_rect(clR->at(i), clR->at(i+1));
			std::cout << "\t" << GSL_REAL(complex_tip_L1) << "\t" << GSL_IMAG(complex_tip_L1) << "\n";
			std::cout << "\t" << GSL_REAL(complex_tip_R1) << "\t" << GSL_IMAG(complex_tip_R1) << "\n";
			std::cout << "\t" << GSL_REAL(complex_tip_L2) << "\t" << GSL_IMAG(complex_tip_L2) << "\n";
			std::cout << "\t" << GSL_REAL(complex_tip_R2) << "\t" << GSL_IMAG(complex_tip_R2) << "\n";
		}
		trans++;
	}
*/


	// Tip observation initialization using pointer arithmetic. Should vastly improve the speed.
		/*
		for (std::list<Patron*>::iterator it_p = patronList.begin(); it_p != patronList.end(); it_p++)
		{
			int oneTimeSize = 2 * numSteps;
			int oneTransSize = numTimepoints * oneTimeSize;
			int oneNodeSize = numTranscripts * oneTransSize;
			int oneTreeSize = numTaxa * oneNodeSize;
			int oneClSize = 2 * oneTreeSize;

			int locus = (*it_p)->getId();
			double* cl = condLikes->getCls(1, 0, locus, 0, 0);
			double* cf = (*it_p)->getCfData(0,0,0);
			for (int i = 0; i < numTaxa; i++)
			{
				for (int k = 0; k < numTimepoints; k++)
				{
					for (int l = 0; l < numSteps; l++)
					{
						cl[]

						cl[i * j + j * k + k * l + 1] = GSL_REAL(cf[i * k + k * l + l]);
						cl[i * j + j * k + k * l + l + 1] = GSL_IMAG(cf[i * k + k * l + l]);
						//(*(cl_real + 2*l)) = GSL_REAL((*it_p)->getCfData(i,k,l));
						//(*(cl_real + 2*l + 1)) = GSL_IMAG((*it_p)->getCfData(i,k,l));


						//double* cl_real2 = condLikes->getCls(1,i,j,k,2*l);
						//(*cl_real2) = GSL_REAL((*it_p)->getCfData(i,k,l));
						//double* cl_imag = condLikes->getCls(1,i,j,k,2*l+1);
						//(*cl_imag) = GSL_IMAG((*it_p)->getCfData(i,k,l));


						std::cout << cl) << "\t" << *(cl_imag) << "\n";
						std::cout << *(cl_real + 2*l) << "\t" << *(cl_real + 2*l + 1) << "\n";
						std::cout << "\n";

					}
				}
			}
			//std::cout << (*it_p)->getName() << " added.\n";
		}
		*/

	condLikes->print();

	/*
		double* x = condLikes->getCls(1,0,0,0,0);
		std::cout << "\t" << (*x) << "\n";
		(*x) = 1.0;
		std::cout << "\t" << (*x) << "\n";
		x = condLikes->getCls(1,0,0,0,0);
		std::cout << "\t" << (*x) << "\n";
	*/

	std::cout << "\n";
}

void Model::initializeFFT(void)
{
	std::cout << "INITIALIZING: FFT\n";
	// init FFT variables
	// NOTE: Can do something clever w/r/t fitting numSteps to datapoint.

	numSteps = settingsPtr->getNumSteps();
	halfSteps = numSteps / 2;
	finalStep = settingsPtr->getFinalStep();
	startStep = settingsPtr->getStartStep();
	stepSize = (finalStep - startStep) / (numSteps - 1);
	ReStepSize = PI / finalStep;

#if 0
	// int oneFFTSize = numSteps * 2;
	// int oneLocusSize = numTimepoints * oneFFTSize;
	// int oneNodeSize = numTranscripts * oneLocusSize;
	// int numNodes = 1;
	// int oneClSize = numNodes * oneNodeSize; // NOTE: For general topologies.
	// std::cout << "oneClSize:" << oneClSize << "\n";
	// int oneClSize =
#endif

	// init data frames
	likeVals = new double[numSteps + 1];	// TODO: Why does this need a correction of +1?
	theta = new double[numSteps];
	//like = new double[2*numSteps];	// CL
	tip1 = new double[2*numSteps];	// CL
	tip2 = new double[2*numSteps];	// CL

	// FFT workspace
	for (int i = 0; i < numSteps; i++) // oneClSize is multiplied by spaces=2 and divided by (Re,Im)=2
	{
	//	REAL(like,i) = 0.0;
	//	IMAG(like,i) = 0.0;
		REAL(tip1,i) = 0.0;
		IMAG(tip1,i) = 0.0;
		REAL(tip2,i) = 0.0;
		IMAG(tip2,i) = 0.0;
		// std::cout << "i:\t" << i << " " << REAL(like,i) << " " << IMAG(like,i) << "\n";
	}

	for (int i = 0; i < numSteps; i++)
	{
		theta[i] = (((i + halfSteps) % numSteps) - halfSteps) * stepSize;
	}

	std::cout << "\n";
}




void Model::initializeParms(void)
{
	std::cout << "INITIALIZING: Tables\n";

#if LAMBDA_ONLY
	proposalProbs.push_back(1.0);	// Lambda
	proposalProbs.push_back(0.0);	// Sigma
	proposalProbs.push_back(0.0);	// Tau-L
	proposalProbs.push_back(0.0);	// Tau-R

#elif SIGMA_ONLY
	proposalProbs.push_back(0.0);	// Lambda
	proposalProbs.push_back(1.0);	// Sigma
	proposalProbs.push_back(0.0);	// Tau-L
	proposalProbs.push_back(0.0);	// Tau-R

#elif TAU1_ONLY
	proposalProbs.push_back(0.0);	// Lambda
	proposalProbs.push_back(0.0);	// Sigma
	proposalProbs.push_back(1.0);	// Tau-L
	proposalProbs.push_back(0.0);	// Tau-R

#elif TAU2_ONLY
	proposalProbs.push_back(0.0);	// Lambda
	proposalProbs.push_back(0.0);	// Sigma
	proposalProbs.push_back(0.0);	// Tau-L
	proposalProbs.push_back(1.0);	// Tau-R
#else

	proposalProbs.push_back(1.0);			// Lambda
	proposalProbs.push_back(1.0);			// Sigma

#endif

	double sum = 0.0;
	for (unsigned int i = 0; i < proposalProbs.size(); i++)
		sum += proposalProbs[i];
	sum = 1 / sum;
	for (unsigned int i = 0; i < proposalProbs.size(); i++)
		proposalProbs[i] *= sum;

	tableList = expressionPtr->getTableList();
	patronList = expressionPtr->getPatronList();

#if !RESEAT

	std::vector<Parm*> initialParms;
	initialParms.push_back(new Lambda(randomPtr, "Lambda"));
	initialParms.push_back(new Sigma(randomPtr, "Sigma"));
	initialParms.push_back(new Tau(randomPtr, "Tau-L"));
	initialParms.push_back(new Tau(randomPtr, "Tau-R"));

	// 05/20/11, SET INITIAL VALUES

	/*
	Lambda* derivedPtrL = dynamic_cast<Lambda*> (initialParms[0]);
	Sigma* derivedPtrS = dynamic_cast<Sigma*> (initialParms[1]);
	Tau* derivedPtrT1 = dynamic_cast<Tau*> (initialParms[2]);
	Tau* derivedPtrT2 = dynamic_cast<Tau*> (initialParms[3]);

	derivedPtrL->getActiveExpMean()->change(-2.0);
	derivedPtrS->getActiveVar()->change(0.1);
	derivedPtrT1->getActiveBrLen()->change(5.0);
	derivedPtrT2->getActiveBrLen()->change(0.5);

	for (unsigned int i = 0; i < initialParms.size(); i++)
	{
		initialParms[i]->keep();
		initialParms[i]->print();
	}

	*/

	tableList.front()->setParmList(initialParms);

#endif


	double a_alpha = settingsPtr->getACRP();
	double b_alpha = settingsPtr->getBCRP();
	alpha = new Alpha(randomPtr, this, a_alpha, b_alpha, "Alpha");

	std::cout << "\n";
}

void Model::updateModel(void)
{

}



double Model::modelLogLikelihood(void)
{
	double lnL = 0.0;

	// Changed from table-based lnL to patron-based lnL for testing (MJL 060211)
	/*

	for (std::list<Table*>::iterator it_t = tableList.begin(); it_t != tableList.end(); it_t++)
	{
		//if ((*it_t)->getUpdateLnL() == true)
		//{
			double tableLnL = tableLogLikelihood(*it_t);
		//	(*it_t)->setUpdateLnL(false);
		//	(*it_t)->setLnL(tableLnL);
			lnL += tableLnL;
		//}
		//else
		//{
		//	lnL += (*it_t)->getLnL();
		//}
	}

	*/

	for (std::list<Patron*>::iterator it_p = patronList.begin(); it_p != patronList.end(); it_p++)
	{
		//std::cout << "Patron id:\t" << (*it_p)->getId() << "\n";
		double patronLnL = locusLogLikelihood(*it_p);
		lnL += patronLnL;
		//std::cout << "lnL:\t" << lnL << "\n";
	}

	return lnL;
}


#if 0
double Model::tableLogLikelihood(Table* t)
{
	double lnL = 0.0;

	// Read in the parameter values.
	double lambda = 0.0;
	double sigma = 0.0;
	double tau1 = 0.0;
	double tau2 = 0.0;

	const std::vector<Parm*> tempParmVector = t->getParmVector();
	bool isRight = false;
	for (std::vector<Parm*>::const_iterator it_p = tempParmVector.begin(); it_p != tempParmVector.end(); it_p++)
	{
		Lambda* derivedPtrL = dynamic_cast<Lambda*> (*it_p);
		Tau* derivedPtrT = dynamic_cast<Tau*> (*it_p);
		Sigma* derivedPtrS = dynamic_cast<Sigma*> (*it_p);
		if (derivedPtrL != 0)
			lambda = derivedPtrL->getActiveExpMean()->getRate();
		else if (derivedPtrS != 0)
			sigma = derivedPtrS->getActiveVar()->getRate();
		else if (derivedPtrT != 0 && isRight == false)
		{
			tau1 = derivedPtrT->getActiveBrLen()->getRate();
			isRight = true;
		}
		else if (derivedPtrT != 0)
		{
			tau2 = derivedPtrT->getActiveBrLen()->getRate();
		}
	}

#if LAMBDA_ONLY
	// TEST 05/06/11 - LAMBDA
	sigma = 0.1;
	tau1 = 2.0;
	tau2 = 0.5;
#elif SIGMA_ONLY
	// TEST 05/06/11 - SIGMA
	lambda = 0.5;
	tau1 = 2.0;
	tau2 = 0.5;
#elif TAU1_ONLY
	// TEST 05/06/11 - TAU1
	lambda = 0.5;
	sigma = 0.1;
	tau2 = 0.5;
#elif TAU2_ONLY
	// TEST 05/06/11 - TAU2
	lambda = 0.5;
	sigma = 0.1;
	tau1 = 2.0;
#endif

	// std::cout << "\t\t" << lambda << " " << sigma << " " << tau1 << " " << tau2 << "\n";

	// Calculate likelihoods for all Patrons of a given table (i.e. labeled to a different Parm classes)
	for (std::list<Patron*>::const_iterator it_p = t->getPatronList().begin(); it_p != t->getPatronList().end(); it_p++)
	{

		int i = 0;

		// set data frame to function vals
		for (i = 0; i < numSteps; i++)
		{
			gsl_complex complex_pdf1 = complexPdf(theta[i], sigma, tau1, lambda);
			gsl_complex complex_pdf2 = complexPdf(theta[i], sigma, tau2, lambda);
			gsl_complex complex_tip1 = (*it_p)->getCfData(0,0,i);
			gsl_complex complex_tip2 = (*it_p)->getCfData(1,0,i);
			gsl_complex conv_tip1 = gsl_complex_mul(complex_pdf1, complex_tip1);
			gsl_complex conv_tip2 = gsl_complex_mul(complex_pdf2, complex_tip2);

			//std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip1\t" << GSL_REAL(complex_pdf1) << " " << GSL_IMAG(complex_pdf1) << "\n";
			//std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip1) << " " << GSL_IMAG(complex_tip1) << "\n";
			//std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip1\t" << GSL_REAL(conv_tip1) << " " << GSL_IMAG(conv_tip1) << "\n";
			//std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip2\t" << GSL_REAL(complex_pdf2) << " " << GSL_IMAG(complex_pdf2) << "\n";
			//std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip2\t" << GSL_REAL(complex_tip2) << " " << GSL_IMAG(complex_tip2) << "\n";
			//std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip2\t" << GSL_REAL(conv_tip2) << " " << GSL_IMAG(conv_tip2) << "\n";

			REAL(tip1,i) = GSL_REAL(conv_tip1);
			IMAG(tip1,i) = GSL_IMAG(conv_tip1);
			REAL(tip2,i) = GSL_REAL(conv_tip2);
			IMAG(tip2,i) = GSL_IMAG(conv_tip2);

			//std::cout << "\n";
		}

		gsl_fft_complex_radix2_inverse(tip1, 1, numSteps);
		gsl_fft_complex_radix2_inverse(tip2, 1, numSteps);

		for (i = 0; i < numSteps; i++)
		{
			gsl_complex complex_tip1;
			GSL_SET_COMPLEX(&complex_tip1, REAL(tip1,i), IMAG(tip1,i));

			gsl_complex complex_tip2;
			GSL_SET_COMPLEX(&complex_tip2, REAL(tip2,i), IMAG(tip2,i));

			gsl_complex final_val = gsl_complex_mul(complex_tip1, complex_tip2);

			REAL(like,i) = GSL_REAL(final_val);
			IMAG(like,i) = GSL_IMAG(final_val);
			likeVals[i] = GSL_REAL(final_val);

			//std::cout << GSL_REAL(final_val) << " " << GSL_IMAG(final_val) << "\n";
			//std::cout << std::setprecision(8) << "\t" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip1) << " " << GSL_IMAG(complex_tip1) << "\n";
			//std::cout << std::setprecision(8) << "\t\ttip2\t" << GSL_REAL(complex_tip2) << " " << GSL_IMAG(complex_tip2) << "\n";
			//std::cout  << "\t\tfinal\t";// << GSL_REAL(final_val) << "\n"; // << " " << GSL_IMAG(final_val) << "\n";
		}

		double val = trapInt(likeVals);

		// NOTE: Prevents negative FFT values from producing NaN in lnL
		if (val <= 0.0 || std::isnan(val)) val = pow(10,-300);

		// std::cout << "\t\t\tLIKELIHOOD: " << val << "\n";
		//std::cout << "\t\t\tLIKELIHOOD: " << val*val << "\n";

		lnL += log(val); // likelihood of data observed for patron
	}

	// return lnL for all datapoints for a patron at the given table
	return lnL;
}

#endif


double Model::locusLogLikelihood(Patron* p)
{
	double lnL = 0.0;

	// Read in the parameter values.
	double lambda = 0.0;
	double sigma = 0.0;
	double tauL = 0.0;
	double tauR = 0.0;

	Table* t = p->getTable();
	const std::vector<Parm*> tempParmVector = t->getParmVector();
	const std::vector<Parm*> tempBranchVector = t->getBranchVector();

	for (std::vector<Parm*>::const_iterator it_p = tempParmVector.begin(); it_p != tempParmVector.end(); it_p++)
	{
		Lambda* derivedPtrL = dynamic_cast<Lambda*> (*it_p);
		Sigma* derivedPtrS = dynamic_cast<Sigma*> (*it_p);
		if (derivedPtrL != 0)
			lambda = derivedPtrL->getActiveExpMean()->getRate();
		else if (derivedPtrS != 0)
			sigma = derivedPtrS->getActiveVar()->getRate();
	}

	// Calculate likelihoods for single Patron (labeled to a different Parm class)
	for (int i = 0; i < numNodes; i++)
	{
		Node* n = topologyPtr->getDownPassNode(i);

		if (n != NULL && n->getLft() != NULL && n->getRht() != NULL)
		{

			//std::cout << "\t" << p->getId() << "\t" << i << "\t" << n->getName() << "\t" << n->getIndex() << "\n";
			//std::cout << "\t" << p->getId() << "\tn:" << n->getIndex() << "\tL:" << n->getLft()->getIndex() << "\tR:" << n->getRht()->getIndex() << "\n";



			int i;

			std::vector<double>* clL = condLikes->getCls(0, n->getLft()->getIndex(), p->getId(), 0);
			std::vector<double>* clR = condLikes->getCls(0, n->getRht()->getIndex(), p->getId(), 0);
			std::vector<double>* clA = condLikes->getCls(0, n->getIndex(), p->getId(), 0);

			//std::cout << "ok\n";

			// get branch lengths (if the branchVector size == 0, initialization occurs)
			if (tempBranchVector.size() > 0)
			{
				//for (int j = 0; j < tempBranchVector.size(); j++)
				//	tempBranchVector[j]->print();
				Tau* derivedPtrT_L = dynamic_cast<Tau*> (tempBranchVector[n->getLft()->getIndex()]);
				Tau* derivedPtrT_R = dynamic_cast<Tau*> (tempBranchVector[n->getRht()->getIndex()]);
				tauL = derivedPtrT_L->getActiveBrLen()->getRate();
				tauR = derivedPtrT_R->getActiveBrLen()->getRate();
			}

			//std::cout << "Parms [l,s,tL,tR] = " << lambda << "\t" << sigma << "\t" << tauL << "\t" << tauR << "\n";

			// set data frame to function vals
			for (i = 0; i < numSteps; i++)
			{
				gsl_complex complex_pdf_L = complexPdf(theta[i], sigma, tauL, lambda);
				gsl_complex complex_pdf_R = complexPdf(theta[i], sigma, tauR, lambda);
				//gsl_complex complex_tip_L2 = p->getCfData(0,0,i);
				//gsl_complex complex_tip_R2 = p->getCfData(1,0,i);
				gsl_complex complex_tip_L = gsl_complex_rect(clL->at(2*i), clL->at(2*i+1));
				gsl_complex complex_tip_R = gsl_complex_rect(clR->at(2*i), clR->at(2*i+1));
				gsl_complex conv_tip_L = gsl_complex_mul(complex_pdf_L, complex_tip_L);
				gsl_complex conv_tip_R = gsl_complex_mul(complex_pdf_R, complex_tip_R);

				/*
				std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip1\t" << GSL_REAL(complex_pdf_L) << " " << GSL_IMAG(complex_pdf_L) << "\n";
				std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip_L) << " " << GSL_IMAG(complex_tip_L) << "\n";
				std::cout << std::setprecision(8) << "\tC2" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip_L2) << " " << GSL_IMAG(complex_tip_L2) << "\n";
				std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip1\t" << GSL_REAL(conv_tip_L) << " " << GSL_IMAG(conv_tip_L) << "\n";
				std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip2\t" << GSL_REAL(complex_pdf_R) << " " << GSL_IMAG(complex_pdf_R) << "\n";
				std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip2\t" << GSL_REAL(complex_tip_R) << " " << GSL_IMAG(complex_tip_R) << "\n";
				std::cout << std::setprecision(8) << "\tC2" << i << ":\t" << "tip2\t" << GSL_REAL(complex_tip_R2) << " " << GSL_IMAG(complex_tip_R2) << "\n";
				std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip2\t" << GSL_REAL(conv_tip_R) << " " << GSL_IMAG(conv_tip_R) << "\n";
				std::cout << "\n";
				*/

				//clL->at(i) = GSL_REAL(conv_tip_L);
				//clR->at(i) = GSL_
				REAL(tip1,i) = GSL_REAL(conv_tip_L);
				IMAG(tip1,i) = GSL_IMAG(conv_tip_L);
				REAL(tip2,i) = GSL_REAL(conv_tip_R);
				IMAG(tip2,i) = GSL_IMAG(conv_tip_R);

				if (std::isnan(GSL_REAL(conv_tip_L))) std::cerr << "ERROR: conv_tip_L[" << i << "] = NaN\n";
				if (std::isnan(GSL_REAL(conv_tip_R))) std::cerr << "ERROR: conv_tip_R[" << i << "] = NaN\n";

				//std::cout << "\n";
			}
			//std::cout << "\tFFT\n";

			gsl_fft_complex_radix2_inverse(tip1, 1, numSteps);
			gsl_fft_complex_radix2_inverse(tip2, 1, numSteps);

			//std::cout << "\tiFFT\n";
			for (i = 0; i < numSteps; i++)
			{
				gsl_complex complex_tip1;
				gsl_complex complex_tip2;

				GSL_SET_COMPLEX(&complex_tip1, REAL(tip1,i), IMAG(tip1,i));
				GSL_SET_COMPLEX(&complex_tip2, REAL(tip2,i), IMAG(tip2,i));

				gsl_complex final_val = gsl_complex_mul(complex_tip1, complex_tip2);

				//std::cout << GSL_REAL(complex_tip1) << "\t" << GSL_IMAG(complex_tip1) << "\n";
				//std::cout << GSL_REAL(complex_tip2) << "\t" << GSL_IMAG(complex_tip2) << "\n";
				//std::cout << GSL_REAL(final_val) << "\t" << GSL_IMAG(final_val) << "\n\n";

				clA->at(2*i) = GSL_REAL(final_val);
				clA->at(2*i+1) = GSL_IMAG(final_val);

				//REAL(like,i) = GSL_REAL(final_val);
				//IMAG(like,i) = GSL_IMAG(final_val);
				// likeVals[i] = GSL_REAL(final_val);

				//if (std::isnan(likeVals[i]))
				//{
				//	std::cerr << "ERROR: likeVals[" << i << "] = NaN\n";
				//}

				//std::cout << std::setprecision(8) << "\t" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip1) << " " << GSL_IMAG(complex_tip1) << "\n";
				//std::cout << std::setprecision(8) << "\t\ttip2\t" << GSL_REAL(complex_tip2) << " " << GSL_IMAG(complex_tip2) << "\n";
				//std::cout << std::setprecision(8) << "\t\tfinal\t" << GSL_REAL(final_val) << " " << GSL_IMAG(final_val) << "\n";
			}


			// calculate the likelihood at the root
			if (n->getAnc() == NULL)
			{
				//std::cout << "root found\n";
				for (int i = 0; i < numSteps; i++)
				{
					likeVals[i] = clA->at(2*i);
					//std::cout << likeVals[i] << "\t";
				}
				//std::cout << "\n";

				double val = trapInt(likeVals);

				// NOTE: Prevents negative FFT values from producing NaN in lnL
				if (val <= 0.0 || std::isnan(val)) val = pow(10,-300);

				lnL += log(val); // likelihood of data observed for patron

				// std::cout << std::setprecision(24) << "\t\t\tLIKELIHOOD: " << val << "\n";
				if (std::isnan(log(val)))
				{
					std::cerr << "ERROR: val = NaN\n";
					std::cerr << "\tl:    " << lambda << "\n";
					std::cerr << "\ts:    " << sigma << "\n";
					std::cerr << "\tt1:   " << tauL << "\n";
					std::cerr << "\tt2:   " << tauR << "\n";
			//		std::cerr << "\ttip1: " << t1 << "\n";
			//		std::cerr << "\ttip2: " << t2 << "\n";

				}
			}
		}
	}

	// return lnL for all datapoints for a patron at the given table
	return lnL;
}

double Model::scaleIFFT(double T, double s, int a)
{
	return (PI * T) / (s * a);
}


gsl_complex Model::complexPdf(double T, double s, double t, double a)
{

	gsl_complex denom;
	gsl_complex power;

	GSL_SET_COMPLEX(&denom, 1.0, a*T);
	GSL_SET_COMPLEX(&power, -(T*T*s*s/2), a*T);

	/*
	power = gsl_complex_exp(power);
	power = gsl_complex_mul_real(power, t);
	power = gsl_complex_div(power, denom);
	power = gsl_complex_mul_real(gsl_complex_exp(power), exp(-t));
	*/

	power = gsl_complex_exp(power);
	power = gsl_complex_mul_real(power, t);
	power = gsl_complex_div(power, denom);
	power = gsl_complex_sub_real(power,t);
	power = gsl_complex_exp(power);
	//power = gsl_complex_mul_real(gsl_complex_exp(power), exp(-t));

	if (std::isnan(GSL_REAL(power)))
	{
		std::cerr << "ERROR: complexPdf (" << &power << ") = NaN\n";
		std::cerr << "\tT: " << T << "\n";
		std::cerr << "\ts: " << s << "\n";
		std::cerr << "\tt: " << t << "\n";
		std::cerr << "\ta: " << a << "\n";

	}

	// std::cout << "\t\t\tcomplexPdf:\t" << GSL_REAL(power) << " " << GSL_IMAG(power) << "\n";

	return power;
	//return gsl_complex_mul_real(gsl_complex_exp(power), exp(-t));
}


gsl_complex Model::charFunc(double T, double m, double s)
{
	gsl_complex val;
	GSL_SET_COMPLEX(&val, (-0.5)*s*s*T*T, m*T);
	return gsl_complex_exp(val);
}

double Model::trapInt(double* fn)
{
	double val = 0.0;

	// NOTE: This trapezoidal integration is works for FFT indexed real values.

	for (int i = 1; i < halfSteps; i++)
	{
		val += (fn[i] + fn[i-1]) / 2;
		// std::cout << "\t\t\t\tval[" << i << "]:\t" << val << "\n";
	}
	for (int i = halfSteps; i < numSteps; i++)
	{
		val += (fn[i] + fn[i-1]) / 2;
		// std::cout << "\t\t\t\tval[" << i << "]:\t" << val << "\n";
	}
	val += (fn[0] + fn[numSteps]) / 2;
	// std::cout << "\t\t\t\tval[" << numSteps << ":\t" << val << "\n";

	return val * ReStepSize;
}



Parm* Model::pickParmAtRandom(Table* t)
{

	double u = randomPtr->uniformRv();
	double sum = 0.0;
	for (int i = 0; i < (int)proposalProbs.size(); i++)
	{
		sum += proposalProbs[i];
		if (u < sum)
		{
			return (t->getParmVector())[i];
		}
	}
	return NULL;

}

Parm* Model::pickBranchAtRandom(Table* t)
{

	int i = numBranches * randomPtr->uniformRv();
	return t->getBranchVector()[i];
}

Table* Model::pickTableAtRandom()
{

	// weight probability of selecting a table by the table.#patrons ^ -0.5
	std::vector<double> tableProbs;
	std::list<Table*>::iterator it_t;
	for (it_t = tableList.begin(); it_t != tableList.end(); it_t++)
	{
		tableProbs.push_back( pow( (*it_t)->getPatronList().size(), -0.5) );
	}

	double u = randomPtr->uniformRv();
	double norm = 0.0;
	double sum = 0.0;
	int r_i = -1;
	for (unsigned int i = 0; i < tableProbs.size(); i++)
	{
		norm += tableProbs[i];
	}
	for (unsigned int i = 0; i < tableProbs.size(); i++)
	{
		tableProbs[i] = tableProbs[i] / norm;
	}
	for (unsigned int i = 0; i < tableProbs.size(); i++)
	{
		sum += tableProbs[i];
		if (u < sum)
		{
			r_i = i;
			break;
		}
	}

	it_t = tableList.begin();
	for (int i = 0; i < r_i; i++)
	{
		it_t++;
	}

	return (*it_t);

}


Conc* Model::getActiveConc()
{
	return alpha->getActiveConc();
}

void Model::keep(Parm* p)
{
	p->keep();
}

void Model::restore(Parm* p)
{
	p->restore();
}

void Model::printTables(void)
{
	std::cout << "PRINTING: Tables\n";
	std::cout << "\ttableList.size() = " << tableList.size() << "\n";
	for (std::list<Table*>::iterator it_t = tableList.begin(); it_t != tableList.end(); it_t++)
	{
		(*it_t)->print();
	}
}

#if 0

// SPOOKY GRAVEYARD OF CODE

clsPtrUpL[n] = new double***[numNodes];
clsPtrUpL[n][0] = new double**[numNodes * numTranscripts];
clsPtrUpL[n][0][0] = new double*[numNodes * numTranscripts * numTimepoints];
clsPtrUpL[n][0][0][0] = new double[numNodes * numTranscripts * numTimepoints * numSteps * 2];

for (int i = 0; i < numNodes; i++)
{
	clsPtrUpL[n][i] = clsPtrUpL[n][i-1] + numTranscripts;
	for (int j = 0; j < numTranscripts; j++)
	{
		clsPtrUpL[n][i][j] = clsPtrUpL[n][i][j-1] + numTimepoints;
		for (int k = 0; k < numTimepoints; k++)
		{
			clsPtrUpL[n][i][j][k] = &tip1[n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize];
		}
	}
}

clsPtrUpR[n] = new double***[numNodes];
clsPtrUpR[n][0] = new double**[numNodes * numTranscripts];
clsPtrUpR[n][0][0] = new double*[numNodes * numTranscripts * numTimepoints];
clsPtrUpR[n][0][0][0] = new double[numNodes * numTranscripts * numTimepoints * numSteps * 2];

for (int i = 0; i < numNodes; i++)
{
	clsPtrUpR[n][i] = clsPtrUpR[n][i-1] + numTranscripts;
	for (int j = 0; j < numTranscripts; j++)
	{
		clsPtrUpR[n][i][j] = clsPtrUpR[n][i][j-1] + numTimepoints;
		for (int k = 0; k < numTimepoints; k++)
		{
			clsPtrUpR[n][i][j][k] = &tip2[n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize];
		}
	}
}

#endif

#if 0

	int oneFFTSize = numSteps * 2;
	int oneLocusSize = numTimepoints * oneFFTSize;
	int oneNodeSize = numTranscripts * oneLocusSize;
	//int numNodes = 1;
	int oneClSize = numNodes * oneNodeSize; // NOTE: For general topologies.

	// std::cout << "oneClSize:" << oneClSize << "\n";

	// init data frames
	theta = new double[numSteps];
	like = new double[2*oneClSize];
	tip1 = new double[2*oneClSize];
	tip2 = new double[2*oneClSize];

	for (int i = 0; i < oneClSize; i++) // oneClSize is multiplied by spaces=2 and divided by (Re,Im)=2
	{
		REAL(like,i) = 0.0;
		IMAG(like,i) = 0.0;
		REAL(tip1,i) = 0.0;
		IMAG(tip1,i) = 0.0;
		REAL(tip2,i) = 0.0;
		IMAG(tip2,i) = 0.0;
		// std::cout << "i:\t" << i << " " << REAL(like,i) << " " << IMAG(like,i) << "\n";
	}

	for (int i = 0; i < numSteps; i++)
	{
		theta[i] = (((i + halfSteps) % numSteps) - halfSteps) * stepSize;
	}

	std::cout << "Data frames initialized.\n";

	// initialize pointer information
	for (int n = 0; n < 2; n++)
	{
		clsPtr[n] = new double****[numNodes];
		clsPtr[n][0] = new double***[numNodes * numTranscripts];
		clsPtr[n][0][0] = new double**[numNodes * numTranscripts * numTimepoints];
		clsPtr[n][0][0][0] = new double*[numNodes * numTranscripts * numTimepoints * numSteps * 2];

		//for (int i = 0; i < numNodes; i++)
		//for (int i = 0; i < 1; i++)
		//{
			int i = 0;
			//clsPtr[n][0] = clsPtr[n][i-1] + numTranscripts;

			for (int j = 1; j < numTranscripts; j++)
			{
				std::cout << "j: " << j << "\n";
				clsPtr[n][i][j] = clsPtr[n][i][j-1] + numTimepoints;
				std::cout << "ok\n";
				for (int k = 1; k < numTimepoints; k++)
				{
					std::cout << "k: " << k << "\n";
					clsPtr[n][i][j][k] = clsPtr[n][i][j][k-1] + (numSteps * 2);
					std::cout << "\t" << n * i * j * k << "\n";
				}
			}
		//}

		//std::cout << "test: " << like[46] << "\n";
		for (int i = 0; i < numNodes; i++)
		{
			for (int j = 0; j < numTranscripts; j++)
			{
				for (int k = 0; k < numTimepoints; k++)
				{
					for(int l = 0; l < numSteps; l++)
					{
						//std::cout << "test: " << like[46] << "\n";
						std::cout << "\t" << n << "\t" << i << "\t" << j << "\t" << k << "\t" << l << "\t";
						std::cout << n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize + l*2 << "\t";
						// clsPtr[n][i][j][k][l] = 0.0;
						std::cout << " = Re:" << like[n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize + l*2] << "\t";
						std::cout << " = Im:" << like[n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize + l*2 + 1] << "\t";
						std::cout << "?\n";
						clsPtr[n][i][j][k][l] = &like[n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize + l*2];
						//std::cout << ".\n";
					}
				}
			}
		}

		/*
		 * for (int i = 0; i < numNodes; i++)
			for (int j = 0; j < numSites; j++)
				clsPtrUpL[n][i][j] = &clsUpL[n * oneClSize + i * oneNodeSize + j * numStates];
		 *
		 */


		clsPtrUpL[n] = new double****[numNodes];
		clsPtrUpL[n][0] = new double***[numNodes * numTranscripts];
		clsPtrUpL[n][0][0] = new double**[numNodes * numTranscripts * numTimepoints];
		clsPtrUpL[n][0][0][0] = new double*[numNodes * numTranscripts * numTimepoints * numSteps * 2];

		for (int i = 1; i < numNodes; i++)
		{
			clsPtrUpL[n][i] = clsPtrUpL[n][i-1] + numTranscripts;
			for (int j = 1; j < numTranscripts; j++)
			{
				clsPtrUpL[n][i][j] = clsPtrUpL[n][i][j-1] + numTimepoints;
				for (int k = 1; k < numTimepoints; k++)
				{
					clsPtrUpL[n][i][j][k] = clsPtrUpL[n][i][j][k-1] + (numSteps * 2);
				}
			}
		}

		for (int i = 0; i < numNodes; i++)
			for (int j = 0; j < numTranscripts; j++)
				for (int k = 0; k < numTimepoints; k++)
					for(int l = 0; l < (2 * numSteps); l++)
						clsPtrUpL[n][i][j][k][l] = &tip1[n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize + l];


		clsPtrUpR[n] = new double****[numNodes];
		clsPtrUpR[n][0] = new double***[numNodes * numTranscripts];
		clsPtrUpR[n][0][0] = new double**[numNodes * numTranscripts * numTimepoints];
		clsPtrUpR[n][0][0][0] = new double*[numNodes * numTranscripts * numTimepoints * numSteps * 2];

		for (int i = 1; i < numNodes; i++)
		{
			clsPtrUpR[n][i] = clsPtrUpR[n][i-1] + numTranscripts;
			for (int j = 1; j < numTranscripts; j++)
			{
				clsPtrUpR[n][i][j] = clsPtrUpR[n][i][j-1] + numTimepoints;
				for (int k = 1; k < numTimepoints; k++)
				{
					clsPtrUpR[n][i][j][k] = clsPtrUpR[n][i][j][k-1] + (numSteps * 2);
				}
			}
		}

		for (int i = 0; i < numNodes; i++)
			for (int j = 0; j < numTranscripts; j++)
				for (int k = 0; k < numTimepoints; k++)
					for(int l = 0; l < (2 * numSteps); l++)
						clsPtrUpR[n][i][j][k][l] = &tip2[n * oneClSize + i * oneNodeSize + j * oneLocusSize + k * oneFFTSize + l];





	}

	std::cout << "ok\n";

	// initialize tip conditional likelihoods
	// NOTE: done statically because we have no topology
	//for (int i = 0; i < numTaxa; i++)
	for (int i = 0; i < 1; i++)
	{
		std::cout << "i\n";
		for (int j = 0; j < numTranscripts; j++)
		{
			std::cout << "j\n";
			for (int k = 0; k < numTimepoints; k++)
			{
				std::cout << "k\n";
				//double fpkm = expressionPtr->getExpr(j,i,k);
				//std::cout << "\tfpkm:" << fpkm << "\n";

				for(int l = 0; l < (2 * numSteps); l++)
				{
					std::cout << "l\n";
					double* p0 = clsPtr[0][i][j][k][l];
					double* p1 = clsPtr[1][i][j][k][l];
					double* uL0 = clsPtrUpL[0][i][j][k][l];
					double* uL1 = clsPtrUpL[1][i][j][k][l];
					double* uR0 = clsPtrUpR[0][i][j][k][l];
					double* uR1 = clsPtrUpR[1][i][j][k][l];
				}
				// place observed FPKM into FFT bins



				/*
				MbBitfield *bf = alignmentPtr->getCodonMatrixEntry(i, j);
				for (int s = 0; s < alignmentPtr->getNumSenseCodons(); s++)
				{
					if (bf->isBitSet(s) == true)
					{
						p0[s] = 1.0;
						p1[s] = 1.0;
						uL0[s] = 1.0;
						uL1[s] = 1.0;
						uR0[s] = 1.0;
						uR1[s] = 1.0;
					}
				}
				*/
			}
		}
	}
#endif

#if 0

// table likelihood 05/03/11
double Model::tableLogLikelihood(Table* t)
{

	double lnL = 0.0;

	// Read in the parameter values.
	double lambda = 0.0;
	//double sigma = 1.0;
	//double tau1 = 0.0;
	//double tau2 = 0.0;

	const std::vector<Parm*> tempParmVector = t->getParmVector();
	//bool isRight = false;
	for (std::vector<Parm*>::const_iterator it_p = tempParmVector.begin(); it_p != tempParmVector.end(); it_p++)
	{
		Lambda* derivedPtrL = dynamic_cast<Lambda*> (*it_p);
		//Tau* derivedPtrT = dynamic_cast<Tau*> (*it_p);
		// Sigma* derivedPtrS = dynamic_cast<Sigma*> (*it_p);
		if (derivedPtrL != 0)
			lambda = derivedPtrL->getActiveExpMean()->getRate();
		/*
		else if (derivedPtrS != 0)
			sigma = derivedPtrS->getActiveVar()->getRate();
		else if (derivedPtrT != 0 && isRight == false)
		{
			tau1 = derivedPtrT->getActiveBrLen()->getRate();
			isRight = true;
		}
		else if (derivedPtrT != 0)
		{
			tau2 = derivedPtrT->getActiveBrLen()->getRate();
		}
		*/
	}

	// std::cout << "\t\t" << lambda << " " << sigma << " " << tau1 << " " << tau2 << "\n";

	// Calculate likelihoods for all Patrons of a given table (i.e. labeled to a different Parm classes)
	for (std::list<Patron*>::const_iterator it_p = t->getPatronList().begin(); it_p != t->getPatronList().end(); it_p++)
	{
		double t1 = ((*it_p)->getData())[0][0];
		double t2 = ((*it_p)->getData())[1][0];

		double lnLike1 = randomPtr->lnNormalPdf(lambda, 1.0, t1);
		double lnLike2 = randomPtr->lnNormalPdf(lambda, 1.0, t2);

		lnL += lnLike1 + lnLike2;
	}

	return lnL;
}


// locus likelihood 05/03/11
double Model::locusLogLikelihood(Patron* p)
{
	double lnL = 0.0;

	// Read in the parameter values.
	double lambda = 0.0;
	//double sigma = 1.0;
	//double tau1 = 0.0;
	//double tau2 = 0.0;

	const std::vector<Parm*> tempParmVector = p->getTable()->getParmVector();
	//bool isRight = false;
	for (std::vector<Parm*>::const_iterator it_p = tempParmVector.begin(); it_p != tempParmVector.end(); it_p++)
	{
		Lambda* derivedPtrL = dynamic_cast<Lambda*> (*it_p);
		//Tau* derivedPtrT = dynamic_cast<Tau*> (*it_p);
		// Sigma* derivedPtrS = dynamic_cast<Sigma*> (*it_p);
		if (derivedPtrL != 0)
			lambda = derivedPtrL->getActiveExpMean()->getRate();
		/*
		else if (derivedPtrS != 0)
			sigma = derivedPtrS->getActiveVar()->getRate();
		else if (derivedPtrT != 0 && isRight == false)
		{
			tau1 = derivedPtrT->getActiveBrLen()->getRate();
			isRight = true;
		}
		else if (derivedPtrT != 0)
		{
			tau2 = derivedPtrT->getActiveBrLen()->getRate();
		}
		*/
	}

	// std::cout << "\t\t" << lambda << " " << sigma << " " << tau1 << " " << tau2 << "\n";

	// Calculate likelihoods for all Patrons of a given table (i.e. labeled to a different Parm classes)

	double t1 = (p->getData())[0][0];
	double t2 = (p->getData())[1][0];

	double lnLike1 = randomPtr->lnNormalPdf(lambda, 1.0, t1);
	double lnLike2 = randomPtr->lnNormalPdf(lambda, 1.0, t2);



	//double like1 = randomPtr->normalPdf(lambda, 1.0, t1 - t2);

	//std::cout << "like: " << lnLike1 + lnLike2 << "\n";

	lnL += lnLike1 + lnLike2;

	return lnL;
}

#endif

#if 0
double Model::tableLogLikelihood(Table* t)
{
	double lnL = 0.0;

	// Read in the parameter values.
	double lambda = 0.0;
	double sigma = 0.0;
	double tau1 = 0.0;
	double tau2 = 0.0;

	const std::vector<Parm*> tempParmVector = t->getParmVector();
	bool isRight = false;
	for (std::vector<Parm*>::const_iterator it_p = tempParmVector.begin(); it_p != tempParmVector.end(); it_p++)
	{
		Lambda* derivedPtrL = dynamic_cast<Lambda*> (*it_p);
		Tau* derivedPtrT = dynamic_cast<Tau*> (*it_p);
		Sigma* derivedPtrS = dynamic_cast<Sigma*> (*it_p);
		if (derivedPtrL != 0)
			lambda = derivedPtrL->getActiveExpMean()->getRate();
		else if (derivedPtrS != 0)
			sigma = derivedPtrS->getActiveVar()->getRate();
		else if (derivedPtrT != 0 && isRight == false)
		{
			tau1 = derivedPtrT->getActiveBrLen()->getRate();
			isRight = true;
		}
		else if (derivedPtrT != 0)
		{
			tau2 = derivedPtrT->getActiveBrLen()->getRate();
		}
	}

#if LAMBDA_ONLY
	// TEST 05/06/11 - LAMBDA
	sigma = 0.1;
	tau1 = 2.0;
	tau2 = 0.5;
#elif SIGMA_ONLY
	// TEST 05/06/11 - SIGMA
	lambda = 0.5;
	tau1 = 2.0;
	tau2 = 0.5;
#elif TAU1_ONLY
	// TEST 05/06/11 - TAU1
	lambda = 0.5;
	sigma = 0.1;
	tau2 = 0.5;
#elif TAU2_ONLY
	// TEST 05/06/11 - TAU2
	lambda = 0.5;
	sigma = 0.1;
	tau1 = 2.0;
#endif

	// std::cout << "\t\t" << lambda << " " << sigma << " " << tau1 << " " << tau2 << "\n";

	// Calculate likelihoods for all Patrons of a given table (i.e. labeled to a different Parm classes)
	for (std::list<Patron*>::const_iterator it_p = t->getPatronList().begin(); it_p != t->getPatronList().end(); it_p++)
	{

		int i = 0;

		// set data frame to function vals
		for (i = 0; i < numSteps; i++)
		{
			gsl_complex complex_pdf1 = complexPdf(theta[i], sigma, tau1, lambda);
			gsl_complex complex_pdf2 = complexPdf(theta[i], sigma, tau2, lambda);
			gsl_complex complex_tip1 = (*it_p)->getCfData(0,0,i);
			gsl_complex complex_tip2 = (*it_p)->getCfData(1,0,i);
			gsl_complex conv_tip1 = gsl_complex_mul(complex_pdf1, complex_tip1);
			gsl_complex conv_tip2 = gsl_complex_mul(complex_pdf2, complex_tip2);

			//std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip1\t" << GSL_REAL(complex_pdf1) << " " << GSL_IMAG(complex_pdf1) << "\n";
			//std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip1) << " " << GSL_IMAG(complex_tip1) << "\n";
			//std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip1\t" << GSL_REAL(conv_tip1) << " " << GSL_IMAG(conv_tip1) << "\n";
			//std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip2\t" << GSL_REAL(complex_pdf2) << " " << GSL_IMAG(complex_pdf2) << "\n";
			//std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip2\t" << GSL_REAL(complex_tip2) << " " << GSL_IMAG(complex_tip2) << "\n";
			//std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip2\t" << GSL_REAL(conv_tip2) << " " << GSL_IMAG(conv_tip2) << "\n";

			REAL(tip1,i) = GSL_REAL(conv_tip1);
			IMAG(tip1,i) = GSL_IMAG(conv_tip1);
			REAL(tip2,i) = GSL_REAL(conv_tip2);
			IMAG(tip2,i) = GSL_IMAG(conv_tip2);

			//std::cout << "\n";
		}

		gsl_fft_complex_radix2_inverse(tip1, 1, numSteps);
		gsl_fft_complex_radix2_inverse(tip2, 1, numSteps);

		for (i = 0; i < numSteps; i++)
		{
			gsl_complex complex_tip1;
			GSL_SET_COMPLEX(&complex_tip1, REAL(tip1,i), IMAG(tip1,i));

			gsl_complex complex_tip2;
			GSL_SET_COMPLEX(&complex_tip2, REAL(tip2,i), IMAG(tip2,i));

			gsl_complex final_val = gsl_complex_mul(complex_tip1, complex_tip2);

			REAL(like,i) = GSL_REAL(final_val);
			IMAG(like,i) = GSL_IMAG(final_val);
			likeVals[i] = GSL_REAL(final_val);

			//std::cout << GSL_REAL(final_val) << " " << GSL_IMAG(final_val) << "\n";
			//std::cout << std::setprecision(8) << "\t" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip1) << " " << GSL_IMAG(complex_tip1) << "\n";
			//std::cout << std::setprecision(8) << "\t\ttip2\t" << GSL_REAL(complex_tip2) << " " << GSL_IMAG(complex_tip2) << "\n";
			//std::cout  << "\t\tfinal\t";// << GSL_REAL(final_val) << "\n"; // << " " << GSL_IMAG(final_val) << "\n";
		}

		double val = trapInt(likeVals);

		// NOTE: Prevents negative FFT values from producing NaN in lnL
		if (val <= 0.0 || std::isnan(val)) val = pow(10,-300);

		// std::cout << "\t\t\tLIKELIHOOD: " << val << "\n";
		//std::cout << "\t\t\tLIKELIHOOD: " << val*val << "\n";

		lnL += log(val); // likelihood of data observed for patron
	}

	// return lnL for all datapoints for a patron at the given table
	return lnL;
}

double Model::locusLogLikelihood(Patron* p)
{
	double lnL = 0.0;

	// Read in the parameter values.
	double lambda = 0.0;
	double sigma = 0.0;
	double tau1 = 0.0;
	double tau2 = 0.0;

	Table* t = p->getTable();
	const std::vector<Parm*> tempParmVector = t->getParmVector();
	bool isRight = false;
	for (std::vector<Parm*>::const_iterator it_p = tempParmVector.begin(); it_p != tempParmVector.end(); it_p++)
	{
		Lambda* derivedPtrL = dynamic_cast<Lambda*> (*it_p);
		Tau* derivedPtrT = dynamic_cast<Tau*> (*it_p);
		Sigma* derivedPtrS = dynamic_cast<Sigma*> (*it_p);
		if (derivedPtrL != 0)
			lambda = derivedPtrL->getActiveExpMean()->getRate();
		else if (derivedPtrS != 0)
			sigma = derivedPtrS->getActiveVar()->getRate();
		else if (derivedPtrT != 0 && isRight == false)
		{
			tau1 = derivedPtrT->getActiveBrLen()->getRate();
			isRight = true;
		}
		else if (derivedPtrT != 0)
		{
			tau2 = derivedPtrT->getActiveBrLen()->getRate();
		}
	}

	if (std::isinf(sigma))	std::cerr << "ERROR: sigma = inf\n";
	if (std::isinf(lambda)) std::cerr << "ERROR: lambda = inf\n";
	if (std::isinf(tau1)) std::cerr << "ERROR: tau1 = inf\n";
	if (std::isinf(tau2)) std::cerr << "ERROR: tau2 = inf\n";

	// std::cout << "\t\t" << lambda << " " << sigma << " " << tau1 << " " << tau2 << "\n";

	// Calculate likelihoods for single Patron (labeled to a different Parm class)
	int i;

	double t1 = (p->getData())[0][0];
	double t2 = (p->getData())[1][0];

	// set data frame to function vals
	for (i = 0; i < numSteps; i++)
	{
		gsl_complex complex_pdf1 = complexPdf(theta[i], sigma, tau1, lambda);
		gsl_complex complex_pdf2 = complexPdf(theta[i], sigma, tau2, lambda);
		gsl_complex complex_tip1 = p->getCfData(0,0,i);
		gsl_complex complex_tip2 = p->getCfData(1,0,i);
		gsl_complex conv_tip1 = gsl_complex_mul(complex_pdf1, complex_tip1);
		gsl_complex conv_tip2 = gsl_complex_mul(complex_pdf2, complex_tip2);



		//std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip1\t" << GSL_REAL(complex_pdf1) << " " << GSL_IMAG(complex_pdf1) << "\n";
		//std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip1) << " " << GSL_IMAG(complex_tip1) << "\n";
		//std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip1\t" << GSL_REAL(conv_tip1) << " " << GSL_IMAG(conv_tip1) << "\n";
		//std::cout << std::setprecision(8) << "\tFn" << i << ":\t" << "tip2\t" << GSL_REAL(complex_pdf2) << " " << GSL_IMAG(complex_pdf2) << "\n";
		//std::cout << std::setprecision(8) << "\tCh" << i << ":\t" << "tip2\t" << GSL_REAL(complex_tip2) << " " << GSL_IMAG(complex_tip2) << "\n";
		//std::cout << std::setprecision(8) << "\tCV" << i << ":\t" << "tip2\t" << GSL_REAL(conv_tip2) << " " << GSL_IMAG(conv_tip2) << "\n";

		REAL(tip1,i) = GSL_REAL(conv_tip1);
		IMAG(tip1,i) = GSL_IMAG(conv_tip1);
		REAL(tip2,i) = GSL_REAL(conv_tip2);
		IMAG(tip2,i) = GSL_IMAG(conv_tip2);

		if (std::isnan(likeVals[i]))
		{
			std::cerr << "ERROR: likeVals[" << i << "] = NaN\n";
		}

		if (std::isnan(GSL_REAL(conv_tip1))) std::cerr << "ERROR: conv_tip1[" << i << "] = NaN\n";
		if (std::isnan(GSL_REAL(conv_tip2))) std::cerr << "ERROR: conv_tip1[" << i << "] = NaN\n";


		//std::cout << "\n";
	}

	gsl_fft_complex_radix2_inverse(tip1, 1, numSteps);
	gsl_fft_complex_radix2_inverse(tip2, 1, numSteps);

	for (i = 0; i < numSteps; i++)
	{
		gsl_complex complex_tip1;
		GSL_SET_COMPLEX(&complex_tip1, REAL(tip1,i), IMAG(tip1,i));

		gsl_complex complex_tip2;
		GSL_SET_COMPLEX(&complex_tip2, REAL(tip2,i), IMAG(tip2,i));

		gsl_complex final_val = gsl_complex_mul(complex_tip1, complex_tip2);

		REAL(like,i) = GSL_REAL(final_val);
		IMAG(like,i) = GSL_IMAG(final_val);
		likeVals[i] = GSL_REAL(final_val);

		if (std::isnan(likeVals[i]))
		{
			std::cerr << "ERROR: likeVals[" << i << "] = NaN\n";
		}

		// std::cout << std::setprecision(8) << "\t" << i << ":\t" << "tip1\t" << GSL_REAL(complex_tip1) << " " << GSL_IMAG(complex_tip1) << "\n";
		// std::cout << std::setprecision(8) << "\t\ttip2\t" << GSL_REAL(complex_tip2) << " " << GSL_IMAG(complex_tip2) << "\n";
		// std::cout << std::setprecision(8) << "\t\tfinal\t" << GSL_REAL(final_val) << " " << GSL_IMAG(final_val) << "\n";
	}

	double val = trapInt(likeVals);

	// NOTE: Prevents negative FFT values from producing NaN in lnL
	if (val <= 0.0 || std::isnan(val)) val = pow(10,-300);

	lnL += log(val); // likelihood of data observed for patron

	// std::cout << std::setprecision(24) << "\t\t\tLIKELIHOOD: " << val << "\n";
	if (std::isnan(log(val)))
	{
		std::cerr << "ERROR: val = NaN\n";
		std::cerr << "\tl:    " << lambda << "\n";
 		std::cerr << "\ts:    " << sigma << "\n";
		std::cerr << "\tt1:   " << tau1 << "\n";
		std::cerr << "\tt2:   " << tau2 << "\n";
		std::cerr << "\ttip1: " << t1 << "\n";
		std::cerr << "\ttip2: " << t2 << "\n";

	}


	// return lnL for all datapoints for a patron at the given table
	return lnL;
}
#endif
